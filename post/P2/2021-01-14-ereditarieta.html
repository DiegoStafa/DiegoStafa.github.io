<!DOCTYPE html>

<html>

<head>
    <title>Diego++</title>

    <!-- meta data-->
    <meta charset="utf-8">
    <meta content="IE=edge" http-equiv="X-UA-Compatible">
    <meta content="width=device-width, initial-scale=1" name="viewport">

    <!-- css -->
    <link rel="stylesheet" href="/css/base.css">
    <link rel="stylesheet" href="/css/post.css">

    <!-- fonts & icons-->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto&display=swap">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
</head>

<body>
    <div class="post-wrapper">
        <ul class="post-info"><li>
Ereditarietà
</li>
<li>
Programmazione 2
</li>
<li>
14-01-2021
</li>
</ul>
<div class="post">
<h2 id="ereditarietà">Ereditarietà</h2>
<p>implementa la relazione di classe di generalizzazione, una classe viene definita come un&#39;altra classe più qualcos&#39;altro</p>
<p>terminologia:</p>
<ul>
<li>classe base, superclasse, supertipo, padre</li>
<li>classe derivata, sottoclasse, sottotipo, figlio</li>
<li>sottotipo proprio significa che è diverso dalla classe base</li>
</ul>
<p>rappresentazione testuale di una gerarchia:</p>
<ul>
<li>sottoclasse &lt;= superclasse</li>
</ul>
<p>i casi d&#39;uso tipici dell&#39;ereditarietà sono:</p>
<ul>
<li>estensione di un tipo<ul>
<li>la sottoclasse aggiunge funzionalità alla superclasse</li>
</ul>
</li>
<li>specializzazione di un tipo<ul>
<li>la sottoclasse è un tipo concreto della superclasse astratta</li>
</ul>
</li>
<li>ridefinizione di un tipo<ul>
<li>la sottoclasse reimplementa i metodi della superclasse (override)</li>
</ul>
</li>
<li>riutilizzo di codice<ul>
<li>non c&#39;è vera ereditarietà, la sottoclasse riutilizza solo il codice, senza subtyping</li>
</ul>
</li>
</ul>
<p><strong>gerarchie di classi</strong></p>
<p>un sottotipo/sottoclasse di dice diretto se deriva direttamente da una classe, indiretto se ci sono uno o più livelli di indirettezza tra il sottotipo e la superclasse</p>
<p><strong>subtyping di tipo</strong></p>
<p>vale solo per l&#39;ereditarietà pubblica</p>
<p>è una forma di polimorfismo sui tipi, nella quale il sottotipo è un tipo di dato è in relazione ad un altro tipo di dato, mediante il concetto di sustituibiità</p>
<p>di base quindi funzioni che operano su una superclasse devono operare normalmente anche sulle sue sottoclassi</p>
<p><strong>subtyping su puntatori</strong></p>
<p>è il polimorfismo, un puntatore ad una superclasse deve tranquillamente poter puntare ad una sottoclasse</p>
<p><strong>subtyping su riferimenti</strong></p>
<p>come per i puntatori</p>
<p><strong>protected</strong></p>
<p>protected significa accessibile mediante sottoggetti</p>
<p>di base è la stessa cosa con il private, fuori dalla classe nemmeno un oggetto della classe stessa può accedere ai membri privati, nello stesso modo, la classe stessa non può accedere nemmeno alla parte protetta</p>
<p><strong>tipi di ereditarietà</strong></p>
<p>ci sono 3 tipi di ereditarietà:</p>
<ul>
<li>sottoclasse : public superclasse --&gt; ereditarietà di tipo<ul>
<li>i membri privati della superclasse sono inaccessibili alla sottoclasse</li>
<li>i membri protetti della superclasse vengono ereditati come membri protetti </li>
<li>i membri pubblici della superclasse vegnon ereditati come membri pubblici</li>
</ul>
</li>
<li>sottoclasse : protected superclasse --&gt; viola information hiding, poco utilizzato<ul>
<li>i membri privati della superclasse sono inaccessibili alla sottoclasse</li>
<li>i membri protetti della superclasse vengono ereditati come membri protetti </li>
<li>i membri pubblici della superclasse vengono ereditati come membri protetti </li>
</ul>
</li>
<li>sottoclasse : private superclasse --&gt; riutillizzo di codice, non supporta subtyping<ul>
<li>i membri privati della superclasse sono inaccessibili alla sottoclasse</li>
<li>i membri protetti della superclasse vegnono ereditati come membri privati</li>
<li>i membri pubblici della superclasse vegnono ereditati come membri privati</li>
</ul>
</li>
</ul>
<p><strong>ereditarietà privata vs has-a</strong></p>
<p>similarità:</p>
<ul>
<li>entrambi creano un sottooggetto</li>
<li>non c&#39;è subtyping</li>
</ul>
<p>differenze:</p>
<ul>
<li>è necessaria la relazione di composizione se servono più oggetti</li>
<li>l&#39;ereditarietà privata introduce l&#39;ereditarietà mulitpla non necessaria</li>
<li>l&#39;ereditarietà privata permette il subtyping di puntatore (polimorfismo)</li>
<li>l&#39;ereditarietà privata da accesso alla parte protetta</li>
</ul>
<p><strong>ereditarietà ed amicizia</strong></p>
<p>le dichiarazioni di amicizia NON sono ereditabili</p>
<p><strong>ridefinizione dei campi</strong></p>
<p>una sottoclasse può ridefinire i campi della superclasse (ad esempio cambiandone tipo)</p>
<p><strong>ridefinizione dei metodi</strong></p>
<p>una sottoclasse può reimplementare i metodi della superclasse</p>
<p><strong>name hiding rule</strong></p>
<p>la ridefinizione di un metodo in una sottoclasse nasconde sempre il metodo della superclasse (solo accessibile tramite scoping)</p>
<p>vuol dire che metodi anche con argomenti diversi vengono nascosti da una sottoclasse che ridefinisce il metodo</p>
<p><strong>costruttore di default</strong></p>
<p>i costruttori delle sottoclassi possono contenere chiamate ai costruttori della superclasse nella lista di inizializzazione</p>
<p>l&#39;ordine di costruzione del compilatore è:</p>
<ul>
<li>prima il sottoggetto</li>
<li>poi i membri dati</li>
</ul>
<p>la costruzione avviene nel seguente modo:</p>
<ol>
<li>viene sempre invocato implicitamente o eplicitamente il costruttore di default del sottoggetto</li>
<li>vengono costruiti i campi della sottoclasse</li>
<li>viene eseguito il corpo del costruttore</li>
</ol>
<p><strong>costruttore di default standard</strong></p>
<p>in assenza di un costruttore di default definito dall&#39;utente, quello standard del compilatore si preoccuperà della costruzione, nel seguente modo:</p>
<ol>
<li>viene invocato il costruttore di default del sottoggetto</li>
<li>vengono costruiti i campi dati con il loro costruttori di default</li>
</ol>
<p><strong>costruttore di copia</strong></p>
<p>la costruzione di copia ridefinita costruisce di <strong>default</strong> i membri della classe, se la lista di inizializzazione è vuota</p>
<p><strong>costruttore di copia standard</strong></p>
<p>la costruzione di copia standard funziona nel seguente modo:</p>
<ol>
<li>il sottogetto dell&#39;oggetto di invocazione viene creato di copia con il parametro del costruttore di copia</li>
<li>i membri dati dell&#39;oggetto di invocazione vengon creati di copia con i membri dati del parametro del costruttore di copia</li>
</ol>
<p><strong>assegnazione standard</strong></p>
<p>si comporta nel seguente modo:</p>
<ol>
<li>il parametro viene assegnato al sottoggetto dell&#39;oggetto di invocazione</li>
<li>campo per campo vengono assegnati il membri dati del parametro all&#39;oggetto di invocazione</li>
</ol>
<p><strong>distruzione standard</strong></p>
<p>si comporta nel seguente modo:</p>
<ol>
<li>invoca il distruttore sui membri dati</li>
<li>invoca il distruttore sul sottoggetto</li>
</ol>
<p><strong>esercizio</strong></p>
<pre><code class="language-c++">/*
definire una superclasse contobancario e 2 sottoclassi, contocorrente e contorisparmio, dove:
1. ogni contobancario ha un saldo e rende disponibili 2 funzionalità: deposito e prelievo
2. ogni contocorrente ha una spesa fissa che verrà detratta dal saldo ad ogni operazione di deposito e prelievo
3. ogni contorisparmio deve avere un saldo non negativo e le operazioni di deposito e prelievo non comportano costi aggiuntivi e restituiscono il saldo

definire inoltre una classe contoarancio sottoclasse di contorisparmio, che contiene un contocorrente, quando si deposita sul contoarancio, la somma viene prelevata dal contocorrente di appoggio e quando si preleva la somma viene depositata
*/

class contobancario
{
    private:
        double saldo;
    public:
        contobancario(double s = 0.0) : saldo(s) {}

        double deposita(double x) {
            return saldo+=x;
        }

        double preleva(double x) {
            return saldo-=x;
        }

        double Saldo() {
            return saldo;
        }
};

class contocorrente : public contobancario
{
    private:
        static double spesa_fissa;
    public:
        double deposita(double x) {
            return contobancario::deposita(x - spesa_fissa);
        }

        double preleva(double x) {
            return contobancario::preleva(x + spesa_fissa);
        }
};

class contorisparmio : public contobancario
{
    private:
    public:
        contorisparmio(double s = 0.0) : contobancario(s) {}

        double deposita(double x) {
            return contobancario::deposita(x);
        }

        double preleva(double x) {
            return (x &lt;= Saldo()) ? contobancario::preleva(x): Saldo();
        }
};

class contoarancio : contorisparmio
{
    private:
        contocorrente&amp; appoggio;
    public:
        contoarancio(contocorrente&amp; cc, double s = 0.0) :
        contorisparmio(s),
        appoggio(cc)
        {}

        double deposita(double x) {
            if(x &gt;= 0)
            {
                appoggio.preleva(x);
                contorisparmio::deposita(x);
            }
            return Saldo();

        }

        double preleva(double x) {
            if(x &lt;= Saldo() &amp;&amp; x &gt;= 0)
            {
                appoggio.deposita(x);
                return contorisparmio::preleva(x);
            }
            return Saldo();
        }
};</code></pre>
<p><strong>ereditarietà multipla</strong></p>
<p>definisce una relazione tra un entità figlia e più entità padri</p>
<p>probelemi:</p>
<ul>
<li>complessità/ambiguità</li>
<li>problema del diamante</li>
</ul>
<p>in c++ viene implementata tramite l&#39;ereditarietà virtuale</p>
<pre><code class="language-c++">// sintassi

#include &quot;orario.h&quot;
#include &quot;data.h&quot;

class dataora : public data, public ora
{
    // ...
};</code></pre>
<p><strong>ambiguità</strong></p>
<p>con ereditarietà multipla si crea ambiguità tra metodi con lo stesso nome in superclassi diverse</p>
<p>soluzione:</p>
<ul>
<li>scoping dei metodi</li>
<li>ridefinizione del metodo nella sottoclasse (nasconde l&#39;ambiguità e costringe lo scoping)</li>
</ul>
<p><strong>problema del diamante</strong></p>
<p>accade quando nell&#39;ereditarietà multipla le superclassi ereditano da una stessa superclasse</p>
<pre><code class="language-c++">// situazione a diamante

class A;

class B : public A;
class C : public A;

class D : public B. public C;

/* 

situazione in memoria

D               
    B
        A
    C
        A

- il sottoggetto A occupa i doppio dello spazio
- ambiguità di subtyping

*/</code></pre>
<p>problemi:</p>
<ul>
<li>si crea ambiguità tra i sottoggetti A quando si fa subtyping di puntatore o quando</li>
<li>si crea un doppio sottoggetto A, spreco di memoria</li>
</ul>
<p>soluzione:</p>
<ul>
<li>derivazione virtuale (non centra nulla con i metodi virtuali)</li>
</ul>
<p><strong>derivazione virtuale</strong></p>
<p>fa sì che non si creino 2 sottoggetti, ma ne venga creato solo uno</p>
<pre><code class="language-c++">class A; // detta anche base virtuale

class B : virtual public A; // passo di derivazione virtuale
class C : virtual public A; // passo di derivazione virtuale

class D : public B. public C; // derivazione finale

/* 

situazione in memoria

D               
    B
        A*
    C
        A*
    A

- B e C guadagnano un puntatore nascosto al sottoggetto A
- il sottoggetto A è unico
- non c&#39;è ambiguità di subtyping
- D si deve occupare di inizializzare A
*/</code></pre>
<p>a differenza della normale ereditarietà, le classi si devono occupare di inizializzare i sottoggetti delle superclassi e anche i sottoggetti delle basi virtuali</p>
<p>siccome la base si occupa di inizializzare la base virtuale, quando si crea un oggetto, vengono ignorate le chiamate ai costruttori delle superclassi alla base virtuale</p>
<p>funzionamento del costruttore:</p>
<ol>
<li>vengono invocati i costruttori delle basi virtuali<ul>
<li>in presenza di più basi virtuali l&#39;ordine è quello di precedenza, left to right - top bottom</li>
<li>la costruzione di una base vrtuale implica automaticamente la costruzione delle sue superclassi</li>
</ul>
</li>
<li>vegono richiamati i costruttori delle basi dirette<ul>
<li>questi costruttori vanno ad ignorare i chiamate ai costruttori delle basi virtuali</li>
</ul>
</li>
<li>vengono costruiti i campi</li>
<li>viene eseguito il corpo</li>
</ol>
<p><strong>unique final overriding</strong></p>
<p>in una derivazione virtuale, se le base virtuale ha un metodo virtuale, e le due sottoclassi ne fanno l&#39;overriding, la sottoclasse finale DEVE fare l&#39;overriding del metodo virtuale della base virtuale</p>
<p>di base la classe sottoclasse deve fare l&#39;overriding di ogni metodo virtuale della base virtuale </p>
<p><strong>visibilità con derivazioni virtuali</strong></p>
<pre><code class="language-c++">class A;

class B : virtual private A;
class C : virtual public A;

class D : public B. public C; // prevale la derivazione più aperta
</code></pre>

        </div>
    </div>
</body>

</html>